# 第一章：概述

## 软件架构的主要思想和特征

### 主要思想

- 思想：将注意力集中在**系统总体结构的组织**上

- 实现手段：运用抽象方法屏蔽模块间的链接，使认知提升并且保持在整体结构的部件“交互”层次，建立“组件+连接件+配置”的软件系统高层结构组织方式

### 软件架构特征

1. 注重可重用性——组件及架构级重用
2. 利益相关者多——平衡需求
3. 关注点分离——模块化、分而治之
4. 质量驱动——关注非功能属性（如质量）
5. 提倡概念完整性
6. 循环风格——用标准方法来处理反复出现的问题





# 第二章：软件架构定义

## 组成派定义

从架构实践的客体**软件**本身入手，强调软件系统的整体**结构和配置**

- 软件是由**架构元素**、**架构形式**和**架构原理**组成的集合

  软件架构={元素，形式，原理}

- 软件架构包括**组件**、**连接件**和**约束**三大要素

## 决策派定义

从架构实践的主体**人**入手，强调软件架构中架构师的**意志和决策**

- 软件架构是架构层次上所有设计决策的集合

## 软件架构决策定义和组成派定义的本质区别？

- **定义入手角度不同：**组成派——架构实践的客体**软件**；决策派——架构事件的主体**人的决策**

- 关注方面不同：组成派——架构的**结果**；决策派——架构的**过程**

## 参考定义框架

软件架构包括**组件**、**连接件**、**配置**、**端口**和**角色**







# 第三章：软件架构模型

## 软件架构建模五类方法

- 基于非规范的**图形**表示的建模方法
- 基于**UML**的建模方法
- 基于**形式化**的建模方法
- 基于**UML形式化**的建模方法
- 其他（文本语言、模型驱动等）

## 软件架构建模方法发展趋势

1. 文本模型（如文档）
2. 图形可视化模型
3. UML模型
4. 形式化模型
5. 未来模型





# 第四章：软件架构风格

## 什么是软件架构风格

是描述**某一特定领域**中系统组织方式的**惯用模式**，作为“可复用的组织模式和习语“为设计人员的交流提供了公共术语空间，促进了设计复用与代码复用

## 20种软件结构风格

### 1.管道过滤器风格

特点：

- 过滤器之间独立。即过滤器独立完成自身功能，相互之间无需进行状态交流
- 过滤器对其处理上下连接的过滤器“无知”
- 结果的正确性不依赖于各个过滤器运行的先后次序

优点：

- 由于每个组件行为不受其它组件影响，整个系统的行为易于理解
- 支持功能模块的复用
- 有较强的可维护性和可拓展性
- 支持一些特定的分析，如吞吐量计算和死锁检测等
- 并发性，多任务并行，提高整体效率

缺点：

- 导致系统处理过程的成批操作
- 因为实际设计可能需要加密，每个过滤器必须对输入输出的数据进行解析和反解析，增加过滤器实现的复杂性
- 交互式处理能力弱

适用范围：批处理、编译器



### 2.主程序/子程序风格

特点：调用返回机制、层次化结构

优点：

- 具有很高的数据访问效率，因为计算共享同一个存储区。
- 不同的计算功能被划分在不同的模块中

缺点：在处理变更的能力上有许多严重的缺陷

- 对数据存储格式的变化将会影响几乎所有的模块
- 对处理流程的改变与系统功能的增强也很难适应
- 难以支持有效的复用

### 3.面向对象风格

特点：

- 对象负责维护其表示的完整性
- 对象的表示对其他对象而言是隐蔽的

优点：

- 对象隐藏了其实现细节，不仅使得对象的使用变得简单、方便，而且具有很高的安全性和可靠性
- 设计者可将一些数据存取操作的问题分解成一些交互的代理程序的集合

缺点：

- 当一个对象和其它对象通过过程调用等方式进行交互时，必须知道其它对象的标识。 
- 无论何时改变对象的标识，都必须修改所有显式调用它的其它对象

实例：检检索系统



### 4.层次化风格

特点：

分层；每层由一系列组件构成；层之间通过接口调用返回关系

优点：

- 支持基于可增加抽象层的设计，允许将一个复杂问题分解成一个增量步骤序列的实现。
- 支持扩展。每一层的改变最多只影响相邻层。
- 支持重用。只要给相邻层提供相同的接口，它允许系统中同一层的不同实现相互交换使用。

缺点：

- 不是所有系统都容易用这种模式来构建
- 定义一个合适的抽象层次可能会非常困难

实例：TCP/IP通信协议



### 5.事件驱动风格

特点：

- 发布者不知道哪些组件会受到事件的影响

- 组件不能对事件的处理顺序或结果做出假设
- 组件提供了一个过程集合和一组事件

优点：

- 事件声明者不需要知道哪些组件会影响事件，组件之间关联较弱
- 提高软件复用能力。只要在系统事件中注册组件的过程，就可以将该组件集成到系统中。
- 系统便于升级。只要组件名和事件中所注册的过程名保持不变，原有组件就可以被新组件替代。

缺点：

- 组件放弃了对计算的控制权，完全由系统来决定
- 存在数据交换问题。
- 正确性验证问题

实例：GUI程序、UI界面



### 6.解释器风格

特点：虚拟机，将高抽象层次的程序翻译为低抽象层次所能理解的指令，以弥合程序语义所期望的与硬件提供的计算引擎之间的差距。

优点：

- 它有利于实现程序的可移植性和语言的跨平台能力
- 可以对未来的硬件进行模拟和仿真，能够降低测试所带来的复杂性和昂贵花费

缺点：

- 额外的间接层次导致了系统性能的下降

实例：JVM



### 7.基于规则的系统风格

基于规则的系统本质上是与解释器风格一致的，都是通过“解释器”(“规则引擎”)，在两个不同的抽象层次之间建立起一种虚拟的环境

优缺点同解释器风格



### 8.仓库风格

特点：仓库是存储和维护数据的中心场所；2种组件：中央数据结构组件、相对独立的组件集合

优点：

- 便于模块间的数据共享，方便模块的添加、更新和删除，避免了知识源的不必要的重复存储等。

缺点：

- 对于各个模块，需要一定的同步/加锁机制保证数据结构的完整性和一致性等。

实例：现代编译器、eclipse



### 9.黑板系统风格

优点：

- 便于多客户共享大量数据
- 既便于添加新的作为知识源代理的应用程序，也便于扩展共享的黑板数据结构
- 知识源可重用
- 支持容错性和健壮性

缺点：

- 不同的知识源代理对于共享数据结构要达成一致，黑板数据结构的修改较为困难
- 需要一定的同步/加锁机制保证数据结构的完整性和一致性，增大了系统复杂度。



### 10.C2风格

特点：通过连接件绑定在一起的按照一组规则运作的并行组件网络。（有点像总线）

优点：

- 可使用任何编程语言开发组件，组件重用和替换易实现
- 该风格具有一定扩展能力，可支持不同粒度的组件
- 组件不需共享地址空间
- 可实现多个用户和多个系统之间的交互
- 可使用多个工具集和多种媒体类型，动态更新系统框架结构

缺点：

- 不太适合大规模流式风格系统
- 对数据库使用比较频繁的使用。



### 11.客户机/服务器风格（C/S风格）

特点：客户机为完成特定的工作向服务器发出请求；服务器处理客户机的请求并返回结果

#### 两层C/S架构

优点：

- 客户机组件和服务器组件分别运行在不同的计算机上，有利于分布式数据的组织和处理
- 组件之间的位置是相互透明的
- 客户机程序和服务器程序可运行在不同的操作系统上，便于实现异构环境和多种不同开发技术的融合
- 软件环境和硬件环境的配置具有极大的灵活性，易于系统功能的扩展
- 将大规模的业务逻辑分布到多个通过网络连接的低成本的计算机上，降低了系统的整体开销。

缺点：

- 开发成本较高
- 客户机程序的设计复杂度大，客户机负荷重
- 信息内容和形式单一
- C/S架构升级需要开发人员到现场操作，增加了维护费用
- 单一的服务器，同时以局域网为中心，难以扩展到互联网
- 数据安全性不高

#### 三层C/S架构

优点：

- 合理地划分三层结构的功能，可以使系统的逻辑结构更加清晰，提高软件的可维护性和可扩充性
- 更有效地选择运行平台和硬件环境，使得每一层都具有清晰的逻辑结构、良好的负荷处理能力和较好的开放性。
- 可以分别选择合适的编程语言并行开发。
- 较高的安全性

缺点：

- 若各层之间通信效率不高，系统整体性能也不高
- 必须慎重考虑三层之间的通信方法、通信频率和传输数据量

实例：浏览器/服务器风格



### 12.浏览器/服务器风格（B/S风格）

特点：客户机上采用了WWW浏览器，将Web服务器作为应用服务器

核心是Web服务器，数据请求、网页生成、数据库访问和应用程序执行全部由Web服务器来完成

系统安装、修改和维护全在**服务器端**解决，客户端无任何业务逻辑。

优点：

- 客户端只需安装浏览器，操作简单
- 运用统一协议，实现跨平台通信
- 开发成本较低，只需要维护Web服务器程序和中心数据库。客户端升级可以通过升级浏览器来实现。

缺点：

- 个性化程度比较低，所有客户端程序的功能都是一样的
- 客户端数据处理能力比较差，加重了Web服务器的工作负担，影响系统的整体性能。
- 数据提交一般以页面为单位，动态交互性不强，不利于在线事物处理
- 可扩展性比较差，系统安全性难以保障。
- 查询中心数据库，其速度要远低于C/S架构



### 13.平台/插件风格

特点：不修改程序主体的情况下对软件功能进行扩展与加强

通过接口连接平台和插件

优点：

- 降低系统各模块之间的互依赖性
- 系统模块独立开发、部署、维护
- 根据需求动态的组装、分离系统

缺点：

- 插件只服务于该主程序，可重用性差

实例：eclipse



### 14.面向Agent风格

特点：Agent：一个能够根据它对其环境的感知，主动采取决策和行为的软件实体。通过Agent之间的合作实现系统的整体目标

自主性、智能性、交互性

优点：

- 对于解决复杂问题是一种好的技术, 特别是对于分布开放异构的软件环境。

缺点：

- 大多数结构中Agent 自身缺乏社会性结构描述和与环境的交互



### 15.面向方面软件架构风格

优点：

- 可以定义交叉的关系，并将这些关系应用于跨模块的、彼此不同的对象模型
- 层次化功能性而不是嵌入功能性，从而使得代码有更好的可读性和易于维护
- 面向对象编程可以很好地合作，互补

实例：网上支付模型



### 16.面向服务架构风格

特点：具有基于标准、松散耦合、共享服务和粗粒度等优势

易于集成现有系统，具有标准化的架构，提高开发效率，降低开发维护复杂度，减少开发成本

优点：

- 灵活性，根据需求变化，重新编排服务。
- 对IT资产的复用
- 使企业的信息化建设真正以业务为核心。

缺点：

- 服务划分困难
- 服务不易编排得当
- 如果接口标准出现问题，会带来额外开销和不稳定性



### 17.正交架构风格

特点：

- 由完成不同功能的n(n>1)个线索(子系统)组成；
- 系统具有m(m >1)个不同抽象级别的层
- 线索之间是相互独立的(正交的)
- 系统有一个公共驱动层(一般为最高层)和公共数据结构(一般为最低层)

优点：

- 结构清晰，易于理解
- 易修改，可维护性强。线索之间相互独立，修改不相互影响
- 可移植性强，重用性高

缺点：

- 不是所有软件系统都能完全正交化，或者完全正交化成本高

实例：汽车服务管理系统



### 18.异构风格

优点：

- 实现遗留代码的重用
- 可以解决解释和表示习惯上不同的问题

缺点：

- 不同风格之间兼容性很难解决

实例：B/S和C/S组合，内外有别、查改有别



### 19.基于层次消息总线的架构风格

优点：

- JB/HMB风格的构件接口是一种基于消息的互联接口，可以较好地支持架构设计。降低了构件之间的耦合性，增强了构件的重用性。
- 支持运行时系统演化，主要体现在可动态增加和删除构件，动态改变构件所响应的消息以及消息过滤这三个方面。

缺点：

- 重用要求高，可重用性差



### 20.模型-视图-控制器风格MVC

优点：

- 多个视图与一个模型相对应。变化——传播机制确保了所有相关视图都能够及时地获取模型变化信息，从而使所有视图和控制器同步，便于维护。
- 具有良好的移植性。由于模型独立于视图，因此可以方便的实现不同部分的移植。
- 当功能发生变化时，改变系统的一个部分就能满足要求。

缺点：

- 增加了系统设计和运行复杂性。
- 视图与控制器连接过于紧密，妨碍了二者的独立重用
- 视图访问模型的效率比较低
- 频繁访问未变化的数据，也将降低系统的性能

实例：大多数用户交互程序的设计中





# 第五章：软件架构描述语言

## 为何有多种软件架构描述语言？

尽管不同的ADL都描述软件架构，却有不同的特点

这些ADL强调了架构不同的侧面，有不同的应用场景：

Aesop支持架构风格的应用，特定领域的软件系统

SADL 提供了关于架构的形式化基础，用户界面密集的系统

C2支持基于消息传递风格的用户界面系统的描述，用户界面密集的系统

Wright支持架构组件之间交互的说明和分析等，复杂交互

# 第六章

## 敏捷开发的基本理念

- 强调个体和互动比强调过程和工具更好
- 强调获得可运行的软件比强调完成详尽的文档好
- 强调与客户合作比强调进行详细的合同谈判好
- 强调响应变化比强调遵循既定的计划好

## 敏捷开发与结构设计关系

1. 软件架构与敏捷开发的出发点是一致的
   - 软件架构与敏捷开发都是一个权衡的过程：软件架构设计需要权衡涉众们的各种需求；敏捷开发是在软件开发过程混沌和大量开发管理活动加入的两个极端中做出的一种权衡
   - 软件架构与敏捷开发目的都是为了提高软
     件开发效率、提高软件质量、降低软件成
     本，将开发团队的价值最大化
2. 敏捷开发也需要重视软件架构
   - 两者在软件开发实践中能够共同存在，且互相促进
3. 敏捷开发改变了软件架构的设计方式。
   - 敏捷开发非常重视软件的架构设计，但是轻架构的详细设计。
   - 敏捷思想中将传统的架构设计分成：种子架构设计+详细架构设计。关注软件系统的骨架或轮廓的设计
   - 敏捷开发将详细架构设计转移到Code编码阶段、
     重构阶段、单元测试阶段等

及早进行编码、测试环节、发布可执行软件

敏捷开发与架构设计冲突与否？

## 敏捷开发中如何改变软件架构设计方式？

区别

敏捷开发把传统软件开发前期的详细架构设计，分散到了整个敏捷开发软件过程中，以达到提高效率、减少风险的目的。

- 敏捷开发非常重视软件的架构设计，但是轻架构的详细设计。
- 敏捷思想中将传统的架构设计分成：种子架构设计+详细架构设计。关注软件系统的骨架或轮廓的设计
- 敏捷开发将详细架构设计转移到编码阶段、
  重构阶段、单元测试阶段等

# 第七章架构驱动的软件开发

## 架构驱动的软件开发步骤

1. 架构需求获取：
   1. 首先将架构需求通过一定的场景进行描述（质量场景）
   2. 接着通过一定的模型描述这些场景，获得架构需求的结构化描述
2. 基本架构设计：是一个迭代过程。架构设计、文档化和评估是一架构驱动软件开发的核心所在
   1. 通过获得的架构需求信息，对架构进行设计并通过文档进行记录
3. 架构记录文档化：方便程序员和分析师进行工作，是软件系统架构的唯一体现方式，文档质量和完整性是架构驱动软件开发成功的关键因素
4. 架构评估：如ATAM等方法对软件架构进行权衡和评估
5. 架构实现
6. 架构维护：质量场景->质量模型

## 质量场景

用于对质量需求的描述

如：用户点击浏览器中的链接，要求系统在1s内返回页面（系统性能的要求）

特定的质量场景是对性能、可移植性、可替换性、可重用性等质量属性产生影响时的质量场景

# 第八章：软件架构设计和实现

## 好的软件架构特点

- 良好模块化

- 适应需求，技术的变化
- 对系统的动态运行有良好的规划
- 对数据的良好规划
- 明确、灵活的部署


## 软件架构的概念和原则引入软件需求阶段

### 好处：

有助于保证需求规约、系统设计之间的可追踪性和一致性，有效保持软件质量

有助于获得更有结构性和可重用性的需求规约

### 不引入产生的问题：

在软件架构设计阶段建立需求规约与架构的映射将相对困难



## MDA（基于模型驱动的软件架构的映射方法

### 基本思想：

将软件系统分成模型和实现两部分：

模型是对系统的描述，实现是利用特定技术在特定平台或环境中对模型的解释

模型仅仅负责对系统的描述，与实现技术无关。

### 应用MDA的好处：

将模型与现实分离后，能够很好地适应技术易变性。当技术发生迁移，只需要针对这用技术作相应的实现，编写相应的运行平台或变换工具。能够较好的应对显示技术发展带来的挑战

# 第15章 软件体系结构评估

## 质量属性、（质量）场景

### 质量属性

1. 可修改性：度量软件系统变化的成本。变化包括功能扩展、容量扩展、结构更新等
2. 可用性：软件能够正常运行的时间比例。可用性=（平均工作时间）/（平均工作时间+平均修复时间）
3. 性能：表现软件系统的响应速度或者由响应速度决定的其他度量
4. 安全性：软件对未授权和非法操作的防卫能力
5. 可测试性：软件系统在多大程度上容易被测试检查出缺陷
6. 易用性：软件系统完成后用户的体验和效率

## ATAM体系结构权衡分析方法

### 基本概念

敏感点：一个或多个构件的特征。使设计师搞清楚实现质量目标时应该注意什么

权衡点：影响多个质量属性的特征。是多个质量属性的敏感点。权衡点需要进行权衡

- 敏感点影响**一个**质量属性；权衡点影响**多个**质量属性

风险承担者、涉众：开发、维护、集成、测试人员、专家等

场景：为得出质量目标而采用的机制

- 刺激：风险承担者怎样引发与系统交互。如，测试人员执行测试、用户激发某个功能等
- 环境：刺激发生时的情况。如当前系处于什么状态、有何特殊约束条件等
- 响应：系统如何通过体系结构对刺激做出反应。如，用户要求的功能是否得到满足、测试人员的测试是否成功等

![1556356875691](C:\Users\温莎公爵\AppData\Roaming\Typora\typora-user-images\1556356875691.png)

### 评估过程

陈述：ATAM方法陈述、商业动机陈述、体系架构陈述

调查分析：确定体系结构方法、生成质量属性效用树、分析体系结构方法

测试：确定场景优先级、分析体系结构方法

形成报告：结果的表述

### 效用树

![1556357181554](C:\Users\温莎公爵\AppData\Roaming\Typora\typora-user-images\1556357181554.png)

架构提出

将场景映射到架构上

根节点（一级节点）写“效用”

二级节点是质量属性：性能，可修改性，可用性，安全性

叶子节点写出优先级

## SAAM软件体系结构分析方法

主要分析体系结构的可修改性

### 评估过程

场景的形成

描述软件体系结构：描述系统的静态特征和动态特征

场景分类和优先级划分：直接场景/间接场景；划分优先级

间接场景的单独评估：直接场景：说明体系结构如何执行；间接场景：说明更改及其代价

评估场景交互：体现体系结构设计中的功能分配

形成总体评估：微场景设置权值、体系结构支持的直接场景数量

## 场景评估的优缺点

优点：

考虑到了所有与系统相关的人员对质量的要求（开发、维护、管理、测试人员以及用户等）

涉及到的基本活动包括**确定应用领域的功能和软件体系结构之间的映射，设计用于体现等待评估质量属性的场景以及分析软件体系结构对于场景的支持程度**

缺点：

**基于场景的评估方式是特定于领域的**。不同的应用系统对于同一质量属性的理解可能不同，对一个领域适合的场景设计在另一个领域内未必合适。

对评估人员专业要求较高。一方面需要**有丰富的领域知识**以对某质量需求设计出合理场景，另一方面**必须对评估的软件体系结构有一定了解**以准确判断它是否支持场景描述的一系列活动。





# 第9章：软件架构的演化和维护

## 静态演化

发生在软件架构设计、实现和维护过程中，软件系统还未运行或者处于停止运行状态

### 需求

1. 设计时的演化需求：在架构开发和实现过程中对原有架构调整，保证软件实现与架构的一致性以及软件开发过程的顺利进行
2. 运行前的演化需求：软件发布后由于环境变化，需要对软件升级，软件架构同样需要演化

### 过程

1. 软件理解：查阅文档，分析家沟，识别系统组成元素以及相互关系，提取系统的抽象表示形式
2. 需求变更分析：找出新的需求变化
3. 演化分析：确定演化范围和成本，选择合适的演化计划
4. 系统重构：根据演化计划进行系统重构，以适应当前需求
5. 系统测试：对演化后的系统测试，找出错误和不足

## 动态演化

发生在软件体系运行过程中

### 需求

1. 软件内部执行所导致的体系结构改变。如：服务器软件在客户请求到达时创建新的组件相应用户需求
2. 软件系统外部的请求对软件进行的重配置。如：操作系统在升级时无需重新启动，在运行过程中对体系结构进行修改

### 类型

交互动态性

结构动态性

架构动态性

### 内容

属性改名：对非功能指标重新定义，如服务响应时间等

行为变化：如：为提高安全级别更换加密算法；将http协议改为https协议

拓扑结构改变：如：增删组件、连接件，改变组件与连接件之间的关联关系

风格变化：变为“衍生”风格，如：两层C/S变为三层C/S结构

### 技术

采用动态软件架构

进行动态配置