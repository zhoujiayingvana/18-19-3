# CPU调度

![1561008745500](C:\Users\温莎公爵\AppData\Roaming\Typora\typora-user-images\1561008745500.png)

放到末尾？

多处理器多级优先队列的调度（期中试题）

# 7——死锁

**发生条件：**

- mutual exclusion 互斥
- hold and wait 占有并等待
- no preemption 非抢占
- circular wait 循环等待

**解决死锁的4种办法：**

- prevention——破坏四个条件
- avoidance——判断current request 是否造成系统处于不安全状态
- detection
- recovery

**死锁avoidance**

==银行家算法经典例题==

**死锁检测：**单实例——wait-for graph；多实例——类似安全算法

**死锁恢复：**进程终止/资源抢占（选择一个牺牲品->回滚到安全状态，重启该进程，释放资源）

# 8——内存管理

**内存保护：**2个寄存器——基址寄存器base REG（页表所在的基地址）+界限寄存器limit REG（逻辑地址）

**程序运行的步骤：**编译->链接->装载load（成为整个程序块）->执行（放入内存中执行）

**<u>地址绑定问题：</u>**绝对装入（单道程序，编译时完成）、可重定位装入（多道程序，静态重定位，load到内存时完成）、动态重定位（装入内存的地址均为相对地址，运行时逐个转为绝对地址）

**<u>逻辑地址和物理地址变化：</u>**逻辑和物理地址在编译和load时地址绑定相同，在执行时地址绑定不同

**动态加载：**routine被call的时候才loading

**动态链接：**linking 和loading都在执行时期，预留一个声明stub

**交换：**就绪队列到就绪的进程之间，中期调度

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20160120184141962)

## 内存连续分配

relocation and limit REG

**固定分区：**每个分区大小相同/分区大小不同。每个分区有自己的job queue或者所有分区共享一个job queue

**可变分区：**根据来的进程大小选择合适大小的block（hole）分配，两个连续的空分区（hole）自动融合，或者一个大的hole可以自动分裂

**动态分配问题：**3种方法：首次适配（地址顺序找第一个能装下进程的）、最佳适配（按hole从小到大找最小能装下进程的）、最差适配（按hole从大到小找最大能装下进程的）

**解决外部碎片的方法**：紧缩compaction，在运行期；不连续，分页/分段

页表实现（寄存器、页表基址寄存器PTBR、硬件快表TLB）：获得内存物理地址需要访问2次内存

**简单页表条目：只储存了帧地址（块地址）**

**页表在内存中。**

Hit Radio（命中率）=a；访问内存时间=b；访问快表时间=c

**EAT：effective access time：**有效访问时间，平均时间=（b+c）a+（2b+c）（1-a）

**页表的内存保护：**有效位、PTLR页表长度寄存器、只读设置

## 两级页表

==为了查询方便，顶级页表最多只能有一个页面==

## 分段

因为段长不一致，内存分配有动态分配问题

段表组成：段长+段首地址

（页表中只有帧的首地址，没有其他）

# 虚存问题&&页表

写时复制 copy-on-write（父进程和子进程一开始如果没有对页进行修改，则共享一个页，修改则单独复制该页，其余的页依然共享）

## 按需调页Demand Paging

减少IO

减少内存的使用

加快响应

增加多道程序度

### 有效访问时间

设缺页率为p

EAT=（1-P）内存访问时间+p缺页处理时间

## 缺页异常

查看页表：非法访问舍弃（一次内存访问），合法访问则执行下面步骤

查找缺页

交换页

更新页，有效位置1

重启产生中断的指令

## 页面置换算法

LRU实现方法：

counter计数器（数组）：每次访问页面，将当前的时钟赋值给页表项的counter，替换counter值最小的那个

双向链表：每次访问页面，将页面添加到top，替换bottom的页。不用搜索。

当CPU要访问一个虚拟地址空间对应的物理内存地址时，先将具体的虚拟地址A/页面大小（4K），结果的商作为页表号，结果的余作为业内地址偏移。（十进制下十分有用）

页号：页的偏移地址。实际页号=该页的页表寄存器基址+页号

页内偏移=物理地址的偏移地址，页表项和帧共用一个偏移量

![1561034705537](C:\Users\温莎公爵\AppData\Roaming\Typora\typora-user-images\1561034705537.png)

## 颠簸

含义：进程忙于换进换出

原因：进程频繁访问的帧数大于系统分配的内存大小，缺页率很高

解决办法：挂起一个进程/设置缺页率的阈值。大了增加分配的帧，小了减少

## MMF内存映射文件

将一个文件/其他对象映射到虚拟内存，实现文件磁盘地址和进程虚拟地址空间的一段虚拟地址的一一映射关系，可以不通过系统调用而是通过访问虚拟内存获得文件地址

![1561009952161](C:\Users\温莎公爵\AppData\Roaming\Typora\typora-user-images\1561009952161.png)



![å¾çç¤ºä¾_ç£çä¸æä»¶ç³»ç».jpg](http://www.ibm.com/developerworks/cn/linux/l-cn-vfs/4.jpg)

# 文件

## 概念

存放在硬盘上的信息的集合，连续的逻辑空间

## 文件分配

### 连续分配

每个文件在磁盘上占有一组连续的块——目录结构：文件名+起始地址+长度（块为单位）

支持随机访问（顺序访问、直接访问）

有外部碎片（动态分配问题）

文件大小不能增加

### 链接分配

每个文件是一截链表——目录结构：文件名+起始块+结束块

无空间浪费（外部碎片），但是每个块有指针，浪费内存

不支持随机访问

隐式链接

显式链接：把pointer集中起来放在FAT中（内存里），减少io次数，提高检索速度，表面上实现了随机访问

### 索引分配

每个文件有一个index block

目录entry指向文件的index  block

数据结构：文件名+index block地址

支持随机访问

有内部碎片

多级索引（链接、分层）

## 文件目录实现

线性列表、哈希表

## 空闲空间管理

位向量：用检索向量代替检索空闲block。需要额外存储空间。容易获得连续的空闲空间

链表：将空白block链接起来。不易获取连续的空闲空间，但是无空间浪费

分组：（链表基础）将连续的空间整合。

计数：（链表嵌套）链表中只存放连续空闲空间的第一个block地址和块数

# 磁盘管理

==磁盘调度法则==